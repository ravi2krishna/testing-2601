2nd Feb 2026
==============

    -> Manual Testing 

        -> Software Testing 

            -> Application Lifecycle / SDLC (Software Development Life Cycle)

                -> Requirement Gathering & Analysis 

                -> Design 

                -> Code Implementation  

                -> Build 

                -> TEST (*)

                -> Deployment  

            -> Software Testing  

                -> Process of evaluating Software Application to ensure Application
                Works Correctly and Meets the Requirement

                -> This Process Involves 

                    -> Various tests to detect any defects or errors

                    -> Ensuring its quality before it's released to end users.

    -> Importance Of Testing

        -> There have been "several instances" where "inadequate software testing" has led to 
        significant consequences 

        -> Therac-25 Radiation Therapy Machine 

            -> In 1980's Therac-25, a radiation therapy machine, was involved in 
            several accidents due to a software bug.

            -> The bug caused the machine to deliver massive overdoses of radiation to patients, 
            leading to injuries and deaths.

            -> Human Life Was a cost 

        -> Mars Climate Orbiter

            -> In 1999, NASA's Mars Climate Orbiter mission failed due to a software error.

            -> This mistake cost NASA approximately $125 million (1000 Crores )

            -> https://en.wikipedia.org/wiki/Mars_Climate_Orbiter

            -> Money Life Was a cost 

    -> NOTE: As you can see, software bugs can create a serious problem, 
    in terms of money, time & lives.

    
    -> Software Testing Concepts 

        -> What is Software 

        -> Types Of Softwares

        -> SDLC (Software Development Life Cycle)

        -> What Is Quality ? 
        
        -> What are Bugs ? 

        -> What are Errors ? 

        -> What are Test Cases ? 

        -> What are Different Types Of Testing We Conduct ? 

        -> STLC (Software "TESTING" Life Cycle)

    -> Any Company / Organization 

        -> Has Three Primary Components 

            -> People 

            -> Product 

            -> Process 

    
    -> What is Software ? 

        -> Collection Of Computer Programs, which helps users to perform certain tasks

        -> Developers will write Different types of Programs based on Requirements 

        -> Types Of Softwares 

            -> System Softwares  

            -> Programming Softwares 

            -> Application Softwares 

    -> System Softwares 

        -> Softwares which are used to run other types of softwares 

            -> Example: Operating System (Win, Linux, Unix)

            -> Examples: Driver Softwares 

                -> Mouse Driver Software 

                -> Graphics Driver Software (Nvidia)

            -> NOTE: Without Having System Softwares, we cannot use 
            any Programming Softwares & Application Softwares 
        

    -> Programming Softwares

        -> Programming Software means Compilers, Debuggers, Interpreters, 
        IDE's(Integrated Development Environments), these are all Programming Software
        used while developing programs.

        -> Compilers: 
            -> Developers Write Source Code (Human Readable Code)
            -> https://github.com/ravi2krishna/login-2516/blob/main/index.html
            -> Compilers will convert Source Code Into An Intermediate Language called as 
            Byte Code 
        -> Interpreters: 
            -> Build Process Converts Byte Code To Machine Readable Code 
            -> We use Interpreters to Translate and Execute Machine Readable Code
            -> https://programming604494160.wordpress.com/wp-content/uploads/2020/06/execution_of_java_program-e1593172039858.jpg
            -> javac is compiler (java compiler)
            -> java is interpreter (jvm)
        -> Debuggers: 
            -> Softwares to Debug Programs, Step by Step to identify the Behavior of Program 
            -> Debuggers helps in identifying Root Cause Problems 
        -> IDE's: 
            -> Used to Write Code, they have code editors, version control(code tracking),
            auto code completion etc 
        -> etc 


3rd Feb 2026
==============

    -> Application Softwares 

        -> Application Software is a type of Software that Enables End Users to 
        perform particular tasks like Writing Documents, Browsing Internet etc 

        -> Microsoft Word 
        -> Chrome 
        -> Firefox 
        -> etc 

    -> NOTE: Using Programming Softwares, We Build Application Softwares

    -> System Software: For Hardware Usage 
    -> Programming Softwares: Developer Focused 
    -> Application Softwares: User Focused 


    -> SDLC 

        -> The Software Development Life Cycle (SDLC) is a "process" followed by 
        software development teams to design, develop, test, deploy and maintain 
        software applications.

        -> SDLC Phases 

            -> Requirement Gathering & Analysis 

                -> In this Phase, the project team identifies and gathers all the 
                Requirements for LMS Application.

                -> Above Phase Includes 

                    -> Understanding Needs Of Users 
                    -> Features & Functionalities 
                    -> Any Constraints and Limitations 

                -> Roles: BA 

                    -> Work: https://docs.google.com/document/d/1ZiOVBYxyeBC-1ZoIgZycsoIIxTVvWy8Q/edit?usp=sharing&ouid=108418800140662749555&rtpof=true&sd=true
            
            -> Design 

                -> One Requirements are Clear 

                -> Design Phase begins 

                    -> Architecture Will Be Decided 

                    -> Overall Structure Of LMS App 

                    -> Modules & Components Of LMS 

                    -> User Interface / User Experience 

                    -> Database Schema Design 

                -> Roles: Software Architects   

                    -> Work: https://www.researchgate.net/profile/Maria-Morales-Rodriguez/publication/270904751/figure/fig1/AS:295101432647697@1447369072607/Architecture-of-an-Intelligent-Learning-Management-System.png

                    -> Work: https://www.researchgate.net/profile/Elise-Lavoue/publication/317507239/figure/fig1/AS:796616361521152@1566939549208/General-architecture-of-a-Project-Based-Learning-Management-System.png


            -> Implementation / Code 

                -> Implementation phase Involves Actual Coding Of LMS App 
                based on System Design

                -> Develop Code For Each Module & Components, meeting the System Design   

                -> Roles: Software Developers & Software Engineers

                    -> Work: https://github.com/ravi2krishna/lms-v1/tree/main/webapp/src/pages 

            
            -> Testing (*)

                -> Testing is Crucial Phase for QA Teams 

                -> Ensure Quality and Correctness Of LMS Application 

                -> Different Types Of Testing 

                    -> Unit Testing 
                    -> Integration Testing 
                    -> White Box Testing
                    -> API Testing 
                    -> Performance Testing 
                    -> etc 

                -> NOTE: Testing is performed and evaluated based on Requirements taken 

                -> Roles: Software Tester & Automation Testers 

                    -> Work: https://drive.google.com/file/d/1-pk-93tW5Vwi0lal73wL8ZAKQ5Bm5zbJ/view?usp=sharing
            

4th Feb 2026
==============

    -> Deployment Phase 

        -> Making Applications Available on Servers / Environments 

        -> Once LMS Application passes all the testing Phases 

            -> We Determine LMS Application is Stable and Production Ready 

        -> Then We Deploy the LMS Application to Live / Production Environment,
        where end users can access and use application

        -> Roles: DevOps Engineers 

            -> Work: https://miro.medium.com/v2/1*pbmStkvxVVYgFUqrEgWhkQ.gif 
            -> Work: https://github.com/ravi2krishna/lms/blob/main/Jenkinsfile

    
    
    -> Maintenance & Support Phase 

        -> After Deployment, the LMS Application enters Maintenance Phase

        -> Here On-going Support is provided for issues 

            -> Bugs reported by user 
                -> Developers will fix the issue with code 
                -> Testers will start testing bug fix 
                -> DevOps Engineer will re-deploy the bug fixed in new iteration / version 

        -> Roles: Support Engineers - Developer - Tester - DevOps Engineer  


    -> NOTE: The Software Development Life Cycle (SDLC) is a "process",
    How to Implement SDLC ? 

    
    -> SDLC Models 

        -> Waterfall Model 

        -> V Model 

        -> Agile Model (Latest & Widely Adopted)


    -> Waterfall Model (1970's)

        -> Software Industry initially began with Waterfall Model

        -> It's also called as Liner or Sequential Model 

        -> It's called Waterfall, because the progress flows Downwards like a waterfall 

            -> https://iso.500px.com/wp-content/uploads/2015/03/Fairy-falls1500px.jpg

            -> https://media.licdn.com/dms/image/v2/D5612AQEWHYW-hDWlog/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1710138974843?e=2147483647&v=beta&t=lIGnYSv1MUWJRUW38M0qaDnSqu9WWYPENj_OiwO1Shw

    -> Waterfall Advantages 

        -> Simplicity: The straightforward nature of the Waterfall model makes it 
        easy to understand and use.

        -> Structured Approach: Clearly defined stages and milestones provide a 
        structured approach to development.

    -> Waterfall Disadvantages 

        -> Inflexibility: The model is rigid and doesn't accommodate changes well 
        once a phase is completed.

        -> Late Testing:  Testing is done at the end of the development process, 
        which can lead to discovering significant issues late in the project.

        -> No working software is available until the final stages of the lifecycle.


    -> When Should We Prefer Waterfall Model 

        -> Requirements should not be changed 
            -> Requirement always should be freezed 

        -> For Smaller Projects 

        -> Less Budget Projects 


    -> V Model (1990's)

        -> V model is known as Verification and Validation Model 

        -> Extension Of Waterfall Model 

        -> Pairing each development phase with a corresponding, parallel testing phase.

        -> It forms a "V" shape, with the left side focused on verification (static analysis) 
        and the right on validation (dynamic testing), 
        ensuring high quality through early test planning. 

        -> Main Advantage Of V Model is in every phase we have testing 

        -> System Design: Constructing the overall system architecture.
            -> LMS Application Architecture
        
        -> High-Level Design: Defining functional modules and components.
            -> LMS Student Module 
            -> LMS Trainer Module 
            -> LMS Admin Module 
            -> LMS Courses Module 
            -> LMS Exam Module 
        
        -> Low-Level Design: Detailed design for individual components.
            -> LMS Student Module (High-Level)
                -> Student Login 
                -> Student Profile  
                -> Student Courses
                    -> Student Courses List 
                    -> Student Courses Buy 
                -> Student Logout  

        -> https://miro.medium.com/v2/1*1_y1njK_-OW_Sqv1cKlDcg.png


    -> Verification (Left Side - Designing):
        -> Requirements Analysis: Defining customer needs.
        -> System Design: Constructing the overall system architecture.
        -> High-Level Design: Defining functional modules and components.
        -> Low-Level Design: Detailed design for individual components.
        
    -> Coding: The actual development phase.
   
    -> Validation (Right Side - Testing):
        -> Unit Testing: Testing individual components.
        -> Integration Testing: Testing combined components.
        -> System Testing: Testing the entire system.
        -> User Acceptance Testing (UAT): Verifying final requirements with users.

    -> Advantages OF V Model

        -> High Quality: Early test planning catches defects early.
        -> Disciplined: Strict, phased, and well-documented process.
        -> Suitable for Small Projects: Works well where requirements are fixed and clear. 

    -> Disadvantages OF V Model

        -> Rigid: Difficult to handle changes once the project starts.
        -> Late Functionality: Working software is not produced until late in the cycle.
        -> High Risk: Not suitable for complex or long-term projects with changing requirements. 


    -> Agile Model (2001)

        -> The Agile model is an "iterative" and "incremental" software development approach 
        focusing on flexibility, collaboration, and rapid delivery of functional components.

        -> By breaking projects into small, time-boxed iterations (sprints), 
        it enables frequent customer feedback, continuous improvement, and 
        adaptation to changing requirements. 
        
        -> Agile prioritizes working software over comprehensive documentation. 

        -> Agile Characteristics and Principles
        
            -> Iterative & Incremental: Software is developed in small, functional, and incremental releases (usually 2–4 week sprints).
            -> Customer Collaboration: Continuous feedback ensures the product meets evolving needs.
            -> Flexibility: Embraces changing requirements, even late in development.
            -> Self-Organizing Teams: Empowered teams manage their own work, fostering productivity and technical excellence.
            -> Reduced Documentation: Focuses on code over documentation

        -> Advantages: 

            -> High customer satisfaction, fast, high-quality, adaptable, and allows for changes.

        -> Disadvantages: 

            -> Minimal documentation makes maintenance difficult, high dependency on client interaction,

        -> Common Agile Frameworks 
            -> Scrum: Focuses on fixed-length iterations called sprints.(*)
            -> Kanban: Focuses on continuous delivery and workflow visualization.


5th Feb 2026
==============

    -> Agile Model 

        -> Agile Model is Development Centric / Focused 



Application / Myntra (Ecommerce)

    -> Agile 

        -> v1: Requirement -> Code -> Test -> Deploy 

            -> Agile Development (Frequent Tests are Done, but not deployments)

                -> Requirement -> Code -> Test
                -> Requirement -> Code -> Test
                -> Requirement -> Code -> Test
                -> Deploy  

        -> v2: Requirement -> Code -> Test -> Deploy 

        -> v3: Requirement -> Code -> Test -> Deploy 

    
    -> DevOps (Agile Operations) - 2016 

        -> Agile Operating (Frequent Deployments are Done)

                -> Requirement -> Code -> Test -> Deploy  
                -> Requirement -> Code -> Test -> Deploy  
                -> Requirement -> Code -> Test -> Deploy   

            -> New Tools & Technologies 

                -> Docker (Faster)
                -> Kubernetes (Stable 24/7 Operational Uptime)
                -> CI/CD Tools (ArgoCD, GitHub Actions, Azure DevOps)
                
    -> Popular Project Management Tools 

        -> JIRA (Proprietary)
        -> Azure DevOps (SAAS) (Free with limited capacity)
        -> GitHub Projects (Free)

        -> Implementation

            -> https://drive.google.com/file/d/1JkqXFi37bRlmIqHM4QCmMinwQ8ug4wKj/view?usp=sharing


    -> QA (Quality Assurance) vs QC (Quality Control)

        -> Quality Assurance

            -> QA refers to the systematic "process" of ensuring that the product meets 
            specified requirements and standards throughout its development lifecycle.

            -> QA activities include process audits, defining quality standards, and 
            implementing best practices to improve overall quality. 

        -> Quality Control

            -> QC involves the "activities" and "techniques" used to monitor and evaluate 
            the quality of the product or service being developed.

            -> QC activities include testing of software components, 
            validation against requirements, reviews of deliverables. 

            -> As a Manual & Automation Tester we are part of Quality Control

    -> NOTE: 

        -> QA focuses on "preventing" defects by improving processes and ensuring 
        that quality is built into the product from the beginning.

        -> QC focuses on "identifying" defects through testing and inspection, 
        aiming to correct them before the product is released.


    -> Start Testing 

        -> Requirement -> Code -> Test 

    -> Unit Testing 

        -> Unit Testing means testing the "smallest testable piece of code" (a unit) 

        -> In technical terms a unit means 

            -> a method or
            -> a function 

        -> Requirement

            -> Developers will not develop the software as a while 

            -> Developers will divide the software into different modules / components,
            which in turn gets divided into multiple tasks i.e methods / functions

            -> As soon as coding is done, Developers perform Unit Testing 

        -> Why Unit Testing 

            -> Find Bugs in Early Stages Of Development 
            -> Document Expected Behavior in Early Stages Of Development 

        -> Unit Testing Techniques 

            -> White Box Testing (Structural Testing) 

                -> We use different techniques like 

                    -> Statement/Path Coverage 
                    -> Branch/Decision Coverage 
                    -> Loop Coverage 

            -> Statement/Path Coverage (Each Line/Statement)

                -> Aimed to ensure that every possible path through the software's source code 
                is executed at least once

                -> The developer will write code, for example he has written some 100 lines of code
                Statement/Path Coverage Test means testing each and line of code at least once 

                    print(Welcome To testing class)
                    print(Unit Testing)
                    print(Unit Testing Techniques)

            -> Branch/Decision/Conditional Coverage (Conditions)

                -> Aims to ensure that every "conditional" statement in the program 
                is executed with all possible outcomes at least once during the test process


                    voting app 

                    age = input(Enter You Age) # 21
                    if age >=18:
                        aadhar_id = input(Enter You AADHAR ID) # 2029202303930
                        if aadhar_id == "1029202303930":
                            print("You Can Vote)
                        else:
                            print(You Cannot Vote Invalid ID) 
                    else:
                    print(You Cannot Vote Underage) 

            -> Loop Coverage (Repeated Actions)

                -> Loop Coverage is dedicated to thoroughly testing the behavior of 
                loop constructs (for, while, do-while) within the application. 
                Loops are used to do repeated actions (Everyday at 12 AM run backup for next month)
                This includes examining loops under various conditions.

                while date != "30-3-2026":
                    print(Taking Backup)

9th Feb 2026
==============

    -> Widely Used Unit Testing Frameworks 

        -> Junit (Java)

            -> A Widely used Framework for Writing and Runnings Tets In Java 

        -> Nunit (.NET)

            -> A Widely used Framework for Writing and Runnings Tets In .NET 

        -> Pytest (Python) 

            -> A Widely used Framework for Writing and Runnings Tets In Python 


    -> NOTE: Unit Testing Code Base - https://github.com/ravi2krishna/JavaCalculator.git

        -> GitHub is a proprietary developer platform that allows developers to 
        create, store, manage, and share their "code".

        -> We can use "mvn test" to perform unit testing 


    -> White Box Testing Technique

        -> SonarQube is a leading open-source platform for continuous inspection of code quality 
        and security, enabling developers to detect bugs, vulnerabilities, and code smells in 
        real-time. 
        
        -> It supports over 30 programming languages, integrates with CI/CD pipelines 
        (e.g., Jenkins, GitHub Actions), and uses quality gates to prevent buggy code 
        from reaching production. 

        -> https://getdx.com/img/optimized/X5yv6FwhKz-3564.webp?_cchid=f850718413d94ef4f2f25cef6c3a56fb

        -> https://github.com/ravi2krishna/lms-v1.git 

        
10th Feb 2026
==============

    -> Integration Testing 

        -> Integration Testing is a level of software testing where 
        individual units or components are combined and tested as a group. 

        -> Integration Testing is performed after unit testing.

        -> The purpose is to identify defects in the "interactions" between integrated units. 

        -> Integration testing ensures that combined units function correctly together and 
        uncover issues related to "interface mismatches", "data flow", and communication between 
        modules.

        -> Focus is not on individual Features 

        -> Focus is on interaction / data flow between modules 

    
    -> Most Popular Applications
        
        -> https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites

    -> LMS Application 

        -> Frontend Module 
        -> Backend Module 
        -> Database Module 

    -> For Above Application Integration Test Checks can include 

        -> UI Sends correct request to API 
        -> API Fetches Data from Database 
        -> API Send correct response to UI 

    -> UI -> API -> DB -> API -> UI 

    -> NOTE: if any link breaks, Integration test failed 

    -> Integration Testing Types 

        -> Incremental Integration Testing

        -> Non-Incremental Integration Testing (Big bang)

    -> Incremental Integration Testing

        -> Incremental integration testing involves developing and testing modules one by one, 
        rather than all at once.

            -> Module 1 -> Module 2 -> Module 3 -> Module 4

                -> https://bugspotter.in/wp-content/uploads/2025/02/Incremental-Integration-Testing-1024x700.webp

        -> Top-Down Integration Testing

            -> Testing starts from the top of the module hierarchy and progresses downward. 
            Higher-level modules are tested first, followed by lower-level modules.

                -> https://www.guru99.com/images/top-down-integration-testing.png

            -> Stubs: Temporary modules that simulate the behavior of lower-level modules that are 
            not yet integrated.

                -> https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRAja2rE8QvYohXNT5NvoyxOsNQ3MeHTuHlcQ&s

            -> UI -> API (Real) -> DB (Stub)

        -> Bottom-Up Integration Testing

            -> Testing starts from the lower level modules hierarchy and progresses upwards. 
            Lower-level modules are tested first, followed by top-level modules.

                -> https://www.guru99.com/images/bottom-up-integration-testing.png

            -> Drivers: Temporary modules that simulate the behavior of higher-level modules that are 
            not yet integrated.

                -> https://techdifferences.com/wp-content/uploads/2018/10/Top-down-vs-bottom-up-integration-testing.jpg

            -> DB -> API (Real) -> UI (Driver)

    
    -> Integration Testing For an Ecommerce Application

        -> Modules

            -> Cart 
            -> Payments 
            -> Orders 
            -> Inventory  
            -> Notifications 

        -> Test Scenarios 

            -> Cart Total -> Payment Amount Matches 
            -> Payment Success -> Order Created 
            -> Order Created -> Inventory reduced 
            -> Order Success -> Email / SMS Triggered 

    -> LMS Application Code 

        -> https://vfunction.com/wp-content/uploads/2024/05/blog-3-tier-application.webp

        -> Every Database Has Address, Username & Password 

            -> 172.17.0.2 - postgres - Login@123 
    

11th Feb 2026
==============

    -> System Testing 

        -> System Testing is a level of software testing where the "complete" and 
        "integrated" software application is tested. 

    -> System testing involves verifying both the "functional" and "non-functional" 
    requirements of the software, ensuring that the system as a whole behaves 
    as expected.

    -> After Completion Of Unit Testing & Integration Testing, we perform System Testing 

        -> Functional Testing 

            -> Functional testing focuses on the "functionality" of different features. 
            For example, in an "e-commerce" application, we test 
                -> whether products are displayed correctly, 
                -> if the search function works, 
                -> if products can be added to the cart, 
                -> if payments can be made, and 
                -> if ordered products appear in the order list. 
                
                Each application has its own set of functionalities that need to 
                be tested accordingly.

        -> Non-Functional Testing 

            -> Non-functional testing begins once the application's functionality is stable. 

            -> Non-functional testing includes 
                -> performance testing to assess the application's response time, 
                -> security testing to ensure the application's safety, 
                -> recovery testing, 
                -> load testing, stress testing, and compatibility testing. 
                
            -> These are different types of testing we conduct under non-functional testing.

    -> NOTE: System testing is entirely up to QA Team (Manual Tester)

    -> GUI Testing 

        -> GUI (Graphical User Interface) Testing involves verifying all "visual elements" 
        of an application to ensure they function correctly and appear as intended. 

        -> It focuses on aspects that users interact with directly, 
        such as buttons, icons, menus, and any other graphical elements.

        -> Visual Design Verification

            -> Layout and Alignment: Ensuring that all elements are properly aligned and 
            follow the design specifications.

            -> Colours and Fonts: Verifying that colours, fonts, and font sizes are 
            consistent with the design guidelines.

            -> Images and Icons: Checking that images and icons are displayed correctly 
            and are not distorted.

        -> Functional Elements Verification

            -> Buttons: Ensuring all buttons perform their intended actions and are 
            responsive when clicked.

            -> Input Fields: Verifying that input fields accept and 
            process user input correctly.
            
            -> Dropdowns and Checkboxes: Checking that dropdown menus and checkboxes 
            function as expected and reflect the correct options and states.

        -> Content Verification

            -> Text Content: Ensuring that all text is free of spelling and grammatical 
            errors and is displayed correctly.

            -> Labels and Messages: Verifying that labels, tooltips, and 
            error messages are appropriate and correctly positioned.

        -> Interaction Elements Verification 

            -> Navigation Menus: Ensuring that navigation menus are working correctly 
            and lead to the appropriate pages.

            -> Links: Verifying that all hyperlinks are functional and 
            direct users to the correct destinations.

            -> Forms: Checking that forms can be submitted and that the data is processed 
            correctly.

    -> Useability Testing 

        -> Usability testing is a method used to assess how easily 
        real users can navigate and interact with a website or application.

        -> This testing focuses on understanding how easy and user-friendly a 
        software application is build 

        -> The goal is to identify any "usability issues" and determine the overall 
        user satisfaction with the software application.

    -> Object Properties Testing 

        -> Input Box: An input box can have properties such as being enabled or disabled. 
        If you want to enter data in the input box, it should be enabled. 
        Sometimes, you might see an input box that is present but 
        you cannot enter any data into it because it is disabled.

        -> Dropdown Element: A drop down should contain multiple options, 
        but typically you can select only one option at a time. 
        In some cases, such as with a multi-select dropdown, 
        you can select multiple options.

        -> Link: Before clicking on a link, it should be in one colour (e.g., blue). 
        After clicking, it should change to another colour.

        -> Radio Button: Consider two radio buttons for selecting gender (male and female). 
        You can select only one at a time. If you select the male button, 
        the female button will be unselected and vice versa.

    -> Error Handling Testing 

        -> Error handling testing ensures that an application correctly handles errors, 
        providing appropriate feedback and maintaining functionality when 
        encountering unexpected conditions or invalid input. 

    -> Calculations Testing 

        -> Calculation testing involves verifying the correctness and accuracy of 
        mathematical operations performed by the application. 

        -> Arithmetic Operations: Addition, subtraction, multiplication, and division.
        -> Financial Calculations: Interest calculations, tax computations, discounts, and total amounts.
        -> Data Processing: Aggregation, averages, percentages, and other statistical operations.

    -> Link Testing 

        -> Links testing is an essential part of "web application" testing 
        that ensures all hyperlinks on a website or web application function correctly. 

        -> Internal Links: Links that point to other pages within the same website.
        -> External Links: Links that point to pages on different websites.
        -> Anchor Links: Links that point to specific sections within the same page.
        -> Email Links: Links that open an email client with a pre-filled recipient address.
        -> Phone Links: Links that open an call option with prefilled phone number 

    -> Cookie Testing 

        -> Cookies are small pieces of data stored on the user's(client) browser 
        by the web application. 

        -> They are used for Auto fill form, passwords, email fields etc

    -> Session Testing 

        -> Sessions store user data on the "server" for the 
        duration of the user's interaction with the web application.

        -> In banking applications, session timeouts are particularly important due to the sensitivity of the data.

            -> Login Process 
            -> Inactivity
            

12th Feb 2026
==============

    -> Non-Functional Testing 

        -> Non-functional testing is a type of software testing that focuses on 
        the non-functional aspects of an application, such as 
        performance, reliability, and scalability. 

        -> Unlike functional testing, which verifies "what the system does", 
        non-functional testing examines "how the system performs".


        -> Performance Testing 

            -> Performance Testing is a type of software testing that ensures a 
            software application performs well under expected workload.

            -> Load Testing 

                -> Load testing evaluates how well an application performs under expected load 
                conditions, such as when 100 or 1000 users access it simultaneously. 

                    -> Simulating Expected Load: Create virtual users to mimic real 
                    user interactions based on customer requirements (e.g., 100 concurrent users).

                    -> Using Tools: Utilize performance testing tools like "LoadRunner" and "JMeter" 
                    to create virtual users and simulate load without needing physical setups.

            -> Stress Testing 

                -> Stress Testing: Determines the system's behavior under 
                extreme conditions, beyond its expected capacity.

                -> Objective: Determine the "breaking point" of the application by 
                testing beyond the expected load.

                -> Gradually increase users from 100 to 120, 150, 200, etc., to see 
                where the application fails.

                -> Stress Tool 

            -> Spike Testing 

                -> Spike Testing: Tests the system’s response to sudden, significant increases in load.

                -> We evaluate how a software system reacts to sudden and extreme 
                increases or decreases in load. 

                -> Simulate Sudden Load Increase: Increase the load suddenly. 
                For example, if the normal load is 100 users, jump to 2000 users instantly.

                -> Zigzag Pattern: Increase and decrease the load rapidly, 
                such as from 100 to 2000 users, then down to 50 users.

            -> Soak / Endurance Testing 

                -> Checks the system’s stability and performance over an extended time period.

                -> Set Up Expected Load: For example, if a customer expects 100 concurrent users, 
                create that environment.
                
                -> Monitor Over Time: Test how long the application can handle the expected load 
                such as half a day, one day, two days, one week, or one month.

            -> Volume Testing 

                -> Volume testing assesses how much data the application's database can handle 
                and its performance under large data volumes.

                -> Insert Large Data Volumes: For example, simulate millions of records 
                being inserted by multiple users.

                -> Monitor Database Performance: Check if the database can handle the data size and 
                if the application remains stable.

                -> Assess Application and Database Stability: Ensure the database does not crash and 
                the application does not break under the data load.

            -> Scalability Testing 

                -> Measures an application's ability to handle increased loads without compromising performance. 

                -> The goal is to determine how well the system scales with an increasing 
                number of users, transactions, or data volume. It ensures that the system can 
                handle growth efficiently and helps identify potential bottlenecks.

        -> Security Testing 

            -> Security Testing is a type of software testing that identifies vulnerabilities, 
            threats, and risks in a software application and helps prevent malicious attacks.

            -> The purpose of security testing is to ensure that software systems are free 
            from any loopholes that might cause a significant loss of information, revenue, or reputation.

            -> Authentication: Validates if users are legitimate and can access the application.

            -> Authorization: Checks if authenticated users have the correct access privileges.

            -> Encryption: Data, especially sensitive information like passwords, should be 
            encrypted during transmission and decrypted upon reaching the server.

            -> Encryption converts data into an unreadable format; 
            decryption converts it back to readable format.
            
            -> Proper encryption and decryption are crucial for secure data transmission.

                -> http://httpforever.com (No Encryption)

                -> https://www.flipkart.com/ (Encryption)

                -> HTTP (HyperText Transfer Protocol): Data is transmitted in plaintext, 
                making it vulnerable to interception.
                
                -> HTTPS (HTTP Secure): Data is encrypted, providing a secure, trusted connection.

        
        -> Recovery Testing 

            -> Recovery Testing ensures a software application can recover from crashes, 
            hardware failures, or other catastrophic problems(datacenter level failures). 

            -> The primary objective of recovery testing is to verify that the system can resume 
            its operations and recover data without any loss after encountering 
            unexpected interruptions or failures.

            -> In terms of Database, we have Primary Database and Secondary Replica Database,
            When issues occur, a failover should happen i.e Application Should Point 
            To Secondary Replica Database


        -> Compatibility Testing 

            -> Verifies whether a software application performs as expected across 
            different environments, including various devices, different operating systems, 
            different browsers, network environments, and hardware configurations.

            -> Operating System Compatibility: Verifies the software's compatibility with various 
            operating systems (e.g., Windows, macOS, Linux, Android, iOS).

            -> Browser Compatibility: Ensures the software performs consistently across
            different web browsers (e.g., Chrome, Firefox, Safari, Edge).